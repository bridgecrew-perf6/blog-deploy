---
title: Database_lab5
tags: Database
index_img: 
banner_img: 
---

# 数据库\_实验5_笔记

三个表如下：

|         表名称         |                            表内容                            |
| :--------------------: | :----------------------------------------------------------: |
|    **B**图书信息表     | ![image-20220504211025640](https://s2.loli.net/2022/05/04/I8lYGWnFjA3kSN2.png) |
| **OD**(读者订购图书表) | ![image-20220504211139907](https://s2.loli.net/2022/05/04/IkEMJf3QAyaVUtj.png) |
| **r**(读者相关信息表)  | ![image-20220504211205623](https://s2.loli.net/2022/05/04/oq6MhCr4HAciflz.png) |

> 三个表的创建代码为：
>
> ```sql
> USE `rbod2`;
> DROP DATABASE `rbod2`;
> CREATE DATABASE RBOD2;
> 
> USE RBOD2;
> 
> CREATE TABLE R
> (
> Rno CHAR(4)   PRIMARY KEY,
> Rname VARCHAR(20),
> STATUS VARCHAR(20),
> CITY VARCHAR(20)
> );
> 
> 
> CREATE TABLE B
> (
> Bno CHAR(4)   PRIMARY KEY,
> Bname VARCHAR(20),
> Price numeric(5,2),
> Pub VARCHAR(20)
> );
> 
> 
> CREATE TABLE OD
> (
> Rno CHAR(4) NOT NULL,
> Bno CHAR(4) NOT NULL,
> Qty SMALLINT,
> PRIMARY KEY(Rno,Bno),
> FOREIGN KEY (Rno) REFERENCES R(Rno),
> FOREIGN KEY (Bno) REFERENCES B(Bno)
> );
> 
> INSERT INTO R VALUES('R1','CHenBing','Student','Beijing');
> INSERT INTO R VALUES('R2','ZhouYucai','Professor','Shanghai');
> INSERT INTO R VALUES('R3','WangLiping','Doctor','Nanjing');
> INSERT INTO R VALUES('R4','LiYong','Student','Shanghai');
> INSERT INTO R VALUES('R5','DingWei','Assistant','Beijing');
> 
> 
> INSERT INTO B VALUES('B1','Modern',15,'Education');
> INSERT INTO B VALUES('B2','Pascal',17,'Qinghua');
> INSERT INTO B VALUES('B3','Scentific',10,'Commerce');
> INSERT INTO B VALUES('B4','PenHuai',9.8,'People');
> INSERT INTO B VALUES('B5','Date Stru',12.6,'Commerce');
> 
> INSERT INTO OD VALUES('R1','B1',2);
> INSERT INTO OD VALUES('R1','B2',1);
> INSERT INTO OD VALUES('R2','B1',3);
> INSERT INTO OD VALUES('R2','B2',3);
> INSERT INTO OD VALUES('R2','B4',4);
> INSERT INTO OD VALUES('R3','B3',1);
> INSERT INTO OD VALUES('R4','B2',2);
> INSERT INTO OD VALUES('R4','B5',1);
> ```

做出如下查询：

1. 找出读者所在城市是“shanghai”的身份是“professor”的读者，或所在城市名包含“jing”的身份为“student”的读者的读者号及身份，按读者号的降序排列。

   ```sql
   SELECT Rno,STATUS 
   FROM r 
   WHERE (CITY = 'shanghai' AND STATUS = 'Professor') OR (city LIKE '%jing%' AND STATUS = 'Student')
   ORDER BY Rno DESC ;
   ```

2. 对每一种有读者订购的图书，找出书号及有读者订购该书读者所在的所有城市，输出结果包括：书号和城市（输出的列取别名）

   ```sql
   SELECT Bno '书号',CITY '城市'
   FROM od,r
   WHERE od.Rno=r.Rno
   ```

3. 找出订购了书号为B2的图书的读者姓名及所在城市(用两种方法做：连接、嵌套)

   ​	连接：

   ```sql
   SELECT Rname,CITY
   FROM od,r
   WHERE od.Bno='B2' AND od.Rno=r.Rno
   ```

   ​	嵌套：

   ```sql
   SELECT Rname,CITY
   FROM r
   WHERE rno IN (
   	SELECT rno 
   	FROM od
   	WHERE Bno='B2'
   );
   ```

   > 本题中，最外层的是找到从r表里找，满足rno条件的（rno条件为:在od表中存在且Bno为‘B2’）。我们可以看到两层嵌套的传递，是其中相关联的列。而且题目所要求条件所在的表在越外层。

4. 找出有一个以上读者订购的图书书号和图书名

   嵌套：（错了！！！！！）

   ```sql
   SELECT Bno,Bname
   FROM b
   WHERE Bno IN(
   	SELECT Bno
   	FROM od
   	/*WHERE Rno IN (
   		SELECT Rno
   		FROM r*/
   	)
   );
   ```

   > 上面的代码从最开始要找的bno与bname，找到存在这两个量的表在b。其中考虑到约束条件：一个以上读者订阅，我们经过观察发现在od表内的所有bno都是有读者订阅的。因此我们考虑嵌套查询od表内的bno。
   >
   > ps.在一开始并没有发现od表内的Bno是都有读者订阅的，所以注释掉一部分依然对。

   聚集函数：

   ```sql
   SELECT b.Bno,bname
   FROM od,b
   WHERE od.Bno=b.Bno
   group by bno 
   having COUNT(*)>1;
   ```

5. 求**至少**订购了**一本**《Pascal》的**读者姓名**

   ```sql
   SELECT Rname
   FROM r
   WHERE Rno IN (
   	SELECT Rno
   	FROM od
   	WHERE Bno='B2'
   );
   ```

   > 题目要求找出读者姓名，我们观察发现读者姓名常出现在r表内有读者姓名。题目约束条件是至少订购一本Pascal。我们发现这本书的书号是B2，我们只要嵌套查询od表内，哪些rno与bno=B2有关系，便可。如果再详细一点便是：

   ```sql
   SELECT Rname
   FROM r
   WHERE Rno IN (
   	SELECT Rno
   	FROM od
   	WHERE Bno IN (
   		SELECT Bno
   		FROM b
   		WHERE Bname='Pascal'
   	)
   );
   ```

   > 上述代码把od表内的Bno与b表中的Bno进行连接

6. 找出**没有订购**B1号图书的读者号

   方法1：

   ```sql
   SELECT rno
   FROM r
   WHERE rno NOT IN (
   	SELECT rno 
   	FROM od
   	WHERE bno='B1'
   );
   ```

   > 上面的是标准答案，第一遍并没有想出来，原因是没有搞清楚嵌套查询的逻辑。通过上面的我们可以看出：先遍历r表中的每个元素即从R1~R5,每次遍历的同时检测这个rno是否符合条件。条件：将rno传到内层查询，如果不在内层查询（NOT IN）即返回真。
   >
   > 在以后查询不符合某种条件时，可以求与之相对的对立面，即符合该种条件，再使用嵌套非语句排除在外。

   方法2:

   ```sql
   SELECT rno
   FROM r
   WHERE  NOT  EXISTS (
   	SELECT *
   	FROM od
   	WHERE bno='B1' AND od.Rno=r.Rno
   );
   ```

   > 我们看到，`NOT IN`与`NOT EXISTS`的区别在于，`NOT IN` 是rno与内层选出来进行比较，而`NOT EXISTS`在于内层循环是否有满足条件。可以理解为一个是`==`，一个是`bool`。

7. 找出价格大于等于15.00或者读者R2最近订购的图书的书号及书名

   ```sql
   SELECT Bno 书号,Bname 书名
   FROM b
   WHERE (Price>=15) OR EXISTS(
   	SELECT *
   	FROM od
   	WHERE Rno='R2'AND od.Bno=b.Bno
   );
   ```

   > where里面可以有两个条件，类比C++里面的`if( )`括号里面的。

8. 求图书B2的订购数

   ```sql
   SELECT Bno 书号,COUNT(Bno)
   FROM od
   WHERE Bno='B2';
   ```

   > COUNT为计数作用，在SELECT里面写。

9. 查询订购的书的数量不确定的(qty是空值)，读者编号和书号

   ```sql
   SELECT rno 读者编号,bno 书号
   FROM od
   WHERE Qty IS  NULL;
   ```

   > 在判断某一个值是否为空的时候要注意用谓词`is`。

10. 查询图书单价不是15,17,10的图书的图书号和图书名及价格

    ```sql
    SELECT Bname 图书名,Bno 图书号,Price 价格
    FROM b
    WHERE Price!=15 AND Price!=17 AND Price!=10
    ```

    > 这题简单！过

11. 查询所有订购了图书的读者的读者号和姓名

    ```sql
    SELECT Rno 读者号,Rname 姓名
    FROM r
    WHERE EXISTS (
    	SELECT *
    	FROM od
    	WHERE Bno IS NULL AND od.Rno=r.Rno
    );
    ```

    > 先对r表中每个人进行遍历，对于每个r中的人，进入内层循环。将od表与r进行连接，并对其中Bno的值判断NULL

12. 查询单价小于等于10的所有图书被读者订购的数量，输出书名和订购总数量

    ```sql
    SELECT b.Bname 书名,SUM(od.Qty) 订购总数量
    FROM b,od
    WHERE od.Bno=b.Bno AND b.Price<=10
    GROUP BY od.Bno;
    ```

    > `sum`对属性列求和，但有`group by` 子句，所以会按照`group by`的结果进行对属性列求和。

13. 查询订购了至少两**种**书的读者姓名和书的种类数

    ```sql
    SELECT rname,COUNT(*)
    FROM r,od
    WHERE r.rno=od.rno
    GROUP BY r.rno
    HAVING COUNT(*)>=2
    ```

    > 这题没做出来，因为不知道如何表示种类数。根据所给答案我们可以看出来，先将od表与r表进行了等值连接，再用`group by` 子句对结果使用rno进行进行聚集，即同一个人的归为一类。同时加入条件`HAVING COUNT(*)`找到至少订购两本书的读者。
    >
    > 这题妙就在于没有直接对rname列进行操作，而是对rno进行操作，使其分类。同时我还学到，`COUNT（*）`与group by连用在处理计数问题上很好用。

14. 查询书价比同一出版社的平均书价高的图书的书号和书名

    ```sql
    SELECT Bno 书号,Bname 书名
    FROM b
    WHERE Price>(
    	SELECT AVG(Price)
    	FROM b bo
    	WHERE bo.Pub=b.Pub
    	GROUP BY (Pub)
    );
    ```

    > 吼吼，这题自己写出来的。大致思路：自身连接，当外层查询每次查询时向内层询问：是否大于平均价格。内层将价格的均值按照Pub分类求均值，如果不加自身连接`WHERE bo.Pub=b.Pub`就会向外层循环返回很多列，所以需要将内外层进行等值连接。

15. 查询每个出版社书价最高的图书是哪些, 输出出版社,书号,书名

    ```sql
    SELECT Pub 出版社, Bno 书号,Bname 书名
    FROM b
    WHERE Price>=ALL (
    	SELECT Price
    	FROM b bo
    	WHERE bo.Pub=b.Pub 
    );
    ```

    > 同上题一个思路，多了“带有ANY（SOME）或ALL谓词的子查询 ”：

     - \>= ANY 大于等于子查询结果中的某个值  
     - \>= ALL 大于等于子查询结果中的所有值
     - = ANY 等于子查询结果中的某个值    
     - !=（或<>）ANY 不等于子查询结果中的某个值
     - !=（或<>）ALL 不等于子查询结果中的任何一个值

16. 找出没有订购B2号图书的读者号，读者的姓名（**用存在谓词查询**）

    ```sql
    SELECT r.Rname 读者姓名
    FROM r
    WHERE NOT EXISTS (
    	SELECT *
    	FROM od
    	WHERE r.Rno=od.Rno AND Bno='B2'
    );
    ```

    > 在这题当中，我发现在`where`语句后面使用`not exists`与在内层嵌套中使用`Bno！=‘B2’`有所不同。不同之处在于，如果是`Bno！=‘B2’`在内层只要存在Bno不为该值的数都返回为真，但会发现**一个读者会订购许多本书**，如果只检测Bno不为该数值，结果就会出错。
    >
    > 在查询时，多考虑完全对立面，例如本题：内层循环为完全对立面，即订购了B2中的读者。

17. 查询读者R4订购的图书的书号和书名（用存在谓词查询）

    ```sql
    SELECT Bno 书号,Bname 书名
    FROM b
    WHERE EXISTS (
    	SELECT *
    	FROM od
    	WHERE od.Bno=b.Bno AND od.Rno='R4'
    );
    ```

    > 同上题，无额外知识点

18. 查询订购了全部书籍的读者的姓名

    由于原题目里没有订购所有书籍的读者，我擅自将od表改成如下样式（Qty属性列为NULL的为我增加的属性列）：

    ![image-20220515130533601](https://s2.loli.net/2022/05/15/nreWgC9fKIJ7ySi.png)

    在一开始，我考虑的是三层嵌套,先查r再查od最后查b。发现行不通，原因是：没有把b中的所有进行比较。下方为修改过的答案：

    ```sql
    SELECT Rname
    FROM r
    WHERE NOT  EXISTS (
    	SELECT *
    	FROM b
    	WHERE NOT  EXISTS(
    		SELECT *
    		FROM od
    		WHERE  r.Rno=od.Rno AND od.Bno=b.Bno
    	)
    );
    ```

    > 先遍历r表中的每个人，在每次遍历到一个人的时候，进入内层查询，检查b表中的所有书是不是都订购了，便进入下一层循环，用od表进行三个表的连接，如果连接有结果，即返回为真，回到第二重查询，查询下一本书。

19. 查询至少订购了R1所订购的书籍的读者的编号（*不会*）

    ```sql
    SELECT DISTINCT rno
    FROM od od1
    WHERE NOT EXISTS(
    	SELECT *
    	FROM od od2
    	WHERE od2.rno='r1' AND NOT EXISTS(
    		SELECT *
    		FROM od od3
    		WHERE od3.rno=od1.rno AND od3.bno=od2.bno
    		)
    );
    ```

    > 这题完全没写出来，简单分析一下：从头到尾只用到了od表，也就是说用了三次自身链接，每次都用的NOT EXISTS，说明每次查询都是找的完全对立面。

20. 把所有Commerce出版社的图书的价格都增加1

    ```sql
    UPDATE b
    SET b.Price=b.Price+1
    WHERE b.Pub='Commerce';
    ```

    > 修改数据：
    >
    > ```sql
    > UPDATE  <表名>
    > SET  <列名>=<表达式>[，<列名>=<表达式>]
    > [WHERE <条件>];
    > ```

21. 把B2读者订购的所有图书的数量改为0

    ```sql
    UPDATE od
    SET Qty=0
    WHERE od.Bno='B2';
    ```

    > 简简单单:smirk:

22. 查询读者表中是否有一个Beijing的读者WangWei,如果有,把他删除

    ```sql
    DELETE 
    FROM r
    WHERE r.CITY='Beijing' AND r.Rname='WangWei';
    ```

    > 删除数据：
    >
    > ```sql
    > DELETE
    > FROM <表名>
    > [WHERE <条件>]；
    > ```

23. 查出每个出版社的图书的平均价格,保存到数据库中(*不会*)

    ```sql
    CREATE TABLE bp(
    Pub CHAR(10),
    avg_price FLOAT);
    
    INSERT INTO bp(Pub,avg_price)
    SELECT pub,AVG(price)
    FROM b
    GROUP BY pub;
    ```

    > 这题很综合，先是题目中*保存到数据库中*的意思，我们应该先建立一个新的数据库，再使用`INSERT INTO`将b表中的两列处理后插入。
    >
    > PS.需要注意的是在插入的时候，要指定插入的列，同时记得**打括号。**

24. 将所有Beijing读者订购的图书数量改为一本

    ```sql
    UPDATE od
    SET od.Qty=1
    WHERE EXISTS(
    	SELECT *
    	FROM r
    	WHERE od.Rno=r.Rno AND r.CITY='Beijing'
    );
    ```

    > 简简单单:grinning:

25. 删去Shanghai的所有读者的订书单

    ```sql
    DELETE
    FROM od
    WHERE EXISTS(
    	SELECT *
    	FROM r
    	WHERE od.Rno=r.Rno AND r.CITY='Shanghai'
    );
    ```

    > 上面是我拿`EXISTS`写的，答案中也可以使用`IN`来写：
    >
    > ```sql
    > DELETE
    > FROM OD
    > WHERE rno in (
    > 	SELECT rno
    > 	FROM R
    > 	WHERE city='上海'
    > );
    > ```

    

  



















